# 算法数据结构体系
## 13、贪心算法

给定一个由字符串组成的数组strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果

## 16、并查集及其相关题目

### 547、省份数量

### 岛问题

给定一个二维数组 matrix，里面的值非1即0，上下左右相邻的1认为是一片岛，返回岛数量

## 18、经典递归

### 汉诺塔

打印n层汉诺塔从最左边移动到最右边的全部过程

### 打印子序列

打印一个字符串的全部子序列

~~~java
class Solution {
  public void print(String s) {
  	
	}
  
  public void process(char[] str,int index,List<String> ans,String path) {
    if (index == str.length) {
      ans.add(path);
      return;
    }
    // 不要当前的
    process(str, index + 1, and, path);
    // 要当前的
    process(str, index + 1, and, path + String.valueOf(str[index]));
  }
}
~~~

打印一个字符串的全部子序列 不要重复

- 使用 set

### 所有字符串的组合

### 逆序栈

给你一个栈，请逆序栈

不能申请额外的数据结构，只能使用递归函数。

## 32、IndexTree & AC 自动机

#### IndexTree

IndexTree 可以根据自身规律很方便的求累加和

~~~
1 2 3 4 5 6 7 8 9 10 11 12
--------------------------- index 管理的范围（只能管理自己以自己之前的）
1 2 3 4 5 6 7 8 9 10 11 12
  1   3   5   7    9    11
      2       6         10
      1       5          9
              4
              3
              2
              1
~~~

某一 index 影响的范围：二进制最右侧 1 消除后加 1

~~~markdown
# 比如 “8” 影响的范围 1~8
1000 -> 0001
# 比如 “12” 影响的范围 9~12
1100 -> 1001
~~~

时间复杂度：O(logN)

~~~java
class IndexTree {
  public int[] tree;
  public int N;
  public IndexTree(int[] arr) {
    N = arr.size;
    tree = new index[N + 1]; // 默认下标从 1 开始，0 不用
  }
  public int sum(int index) {
    int res = 0;
    while (index > 0) {
      res += tree[index];
      index -= index & -index;
    }
    return res;
  }
  public void add(int index, int d) {
    while (index <= N) {
      tree[index] += d;
      index += index & -index
    }
  }
}
~~~



#### AC 自动机

## 34、与 hash 函数有关的结构

SHA-1、SHA-256、SHA-512、MD5-256

## 35、资源限制类题目

1. 布隆过滤器用于集合的建立与查询，并可以节省大量空间
2. 一致性哈希解决数据服务器的负载管理问题
3. 利用并查集结构做岛问题的并行计算
4. 哈希函数可以把数据按照种类均匀分流
5. 位图解决某一范围上数字的出现情况，并可以节省大量空间
6. 利用分段统计思想、并进一步节省大量空间
7. 利用堆、外排序来做多个处理单元的结果合并

#### 

