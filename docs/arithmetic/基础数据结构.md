# 基础数据结构

## 一、Trie

someone read like tree, from retrieval is also corrent.

Trie 树，又叫字典树、前缀树（Prifix Tree）、单词查找树 或 键树，是一种多叉树结构。

字典树的性质

1. 根结点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符
2. 从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串；
3. 任意节点的所有字节点所包含的字符串都不相同

Use cases : 自动补全、拼写检查、IP 路径（最长前缀匹配）、T9（九宫格）打字预测、词频统计（节省内存）

### 模板

常用 method

1. addWord(String word)
2. search(String word)
3. searchPrefix(String prefix)

### 208 [实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

~~~java
// 定义 TrieNode 数据结构
class TrieNode {
  TrieNode[] children;
  boolean isWord;
  public TrieNode() {
    children = new TrieNode[26];
  }
}
class Trie {
		// 成员变量 root
    public Trie() {
			// 初始化 root
    }
    
  	// 此处注意：root 不包含任何字符！
    public void insert(String word) {

    }
    
    public boolean search(String word) {

    }
    
    public boolean startsWith(String prefix) {

    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
~~~

### 211 [ 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure)

~~~java
class WordDictionary {

    public WordDictionary() {

    }
    
    public void addWord(String word) {

    }
    
    public boolean search(String word) {

    }
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */
~~~

### 212 [单词搜索 II（困难）](https://leetcode.cn/problems/word-search-ii/)

~~~java
class Solution {
    public List<String> findWords(char[][] board, String[] words) {

    }
}
~~~

## 二、Union Find 并差集

动态连接（Dynamic connectivity）的问题，什么是Union Find？

并查集 是一种树形的数据结构，用于处理不交集的合并（union）及查询（find）问题。

Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。

Union：将两个子集合并成同一个集合。

### 模板

~~~java
class DSU {
  int[] parent;
  public DSU(int N) {
    parent = new int[N];
    for (int i = 0; i < N; i++) parent[i] = i;
  }
  public int find(int x) {
    if (parent[x] != x) parent[x] = find(parent[x]);
    return parent[x];
  }
  public void union(int x, int y) {
    parent[find(x)] = find(y);
  }
}
~~~

**Improved with size(weighted)**

~~~java
class DSU {
  int[] parent;
  // 记录组中元素数量
  int[] size;
  public DSU(int N) {
    parent = new int[N];
    size = new int[N];
    for (int i = 0; i < N; i++) parent[i] = i;
    // 初始化为 1
    Arrays.fill(size, 1);
  }
  public int find(int x) {
    if (parent[x] != x) parent[x] = find(parent[x]);
    return parent[x];
  }
  
  // 小树挂到大树上
  // 元素数量少的赋给元素数量多的使其平衡，高度不变
  public void union(int x, int y) {
    int rootX = find(x), rootY = find(y);
    if (rootX == rootY) return;
    if (size[rootX] <= size[rootY]) {
      parent[rootX] = rootY;
      size[rootY] += size[rootX];
    } else if (size[rootX] > size(rootY)) {
      parent[rootY] = rootX;
      size[rootX] += size[rootY];
    }
  }
}
~~~

**Improved with ranked**

使用 rank 来优化，rank 代表数的高度或深度。高度低的树向高度高的树合并。

~~~java
class DSU {
  int[] parent;
  // 记录深度
  int[] rank;
  public DSU(int N) {
    parent = new int[N];
    rank = new int[N];
    for (int i = 0; i < N; i++) parent[i] = i;
    Arrays.fill(rank, 1);
  }
  public int find(int x) {
    if (parent[x] != x) parent[x] = find(parent[x]);
    return parent[x];
  }
  public void union(int x, int y) {
    int rootX = find(x), rootY = find(y);
    if (rank[rootX] < rank[rootY]) {
      parent[rootX] = rootY;
    } else if (rans[rootX] > rank[rootY]) {
      parent[rootY] = rootX;
    } else { // 相等时需要维护深度,X 贴给 Y，Y 深度加一
      parent[rootX] = rootY;
      rank[rootY]++;
    }
  }
}
~~~

### 305. Number of Islands 2

### [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)

~~~java
class Solution {
    public int findCircleNum(int[][] isConnected) {

    }
}
~~~

### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence)

~~~java
class Solution {
    public int longestConsecutive(int[] nums) {

    }
}
class DSU {
  int[] parent;
  int[] size;
  
  public DSU(int N){
    
  }
  
  public int find(int x) {
    
  }
  
  // 小树挂到大树上
  public void union(int x, int y) {
    
  }
  
  public int findMax() {
    
  }
}
~~~

## 三、Heap

## 四、栈，队列实现

栈（stack）

栈是限定仅在表尾进行插入和删除操作的线性表。栈又称为后进先出（Last In First Out）的线性表，简称 LIFO 结构。

队列（queue）

队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是一种先进先出（First In First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。

### 155. 最小栈

~~~java
/**
 * two stack
 */
class MinStack {
		Stack<Integer> stack = new Stack<>();
 		Stack<Integer> minStack = new Stack<>();

    public MinStack() {

    }
    
  	// 如果为空或者比栈顶小则 push 进 minStack
    public void push(int val) {

    }
    
    // 如果移除的与 minStack 栈顶一样则同时移除
    public void pop() {

    }
    
    public int top() {

    }
    
    public int getMin() {

    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
~~~

~~~java
/**
 * one stack
 */
class MinStack {
		Stack<int[]> stack = new Stack<>();
    public MinStack() {

    }
    
  	// 存入数组，数组第一个放自身，第二个与上一个第二个比较放入小的。
    public void push(int val) {

    }
    
    public void pop() {

    }
    
    public int top() {

    }
    
    public int getMin() {

    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
~~~









